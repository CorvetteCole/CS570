/*
* Modified from  sample code generated by rpcgen.
* These are only templates and you can use them
* as a guideline for developing your own functions.
*/

#include "ssnfs.h"
#include "virtual_disk.h"

// Create a global VirtualDisk object
VirtualDisk virtualDisk("./virtual_fs");

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

open_output *
open_file_1_svc(open_input *argp, struct svc_req *rqstp) {
    static open_output result;

    // Initialize output message
    result.out_msg.out_msg_len = 0;
    result.out_msg.out_msg_val = NULL;

    // Use VirtualDisk to open the file
    int fd = virtualDisk.open(argp->user_name, argp->file_name);
    if (fd == -1) {
        // Failed to open or create file
        result.fd = -1;
        result.out_msg.out_msg_len = strlen("Failed to open or create file") + 1;
        result.out_msg.out_msg_val = strdup("Failed to open or create file");
        return &result;
    }

    // File opened successfully, set output message
    result.fd = fd;
    result.out_msg.out_msg_len = strlen(argp->file_name) + 1;
    result.out_msg.out_msg_val = strdup(argp->file_name);

    // Set output message
    result.out_msg.out_msg_len = strlen(argp->file_name) + 1;
    result.out_msg.out_msg_val = (char *) malloc(result.out_msg.out_msg_len);
    strcpy(result.out_msg.out_msg_val, argp->file_name);

    return &result;
}

read_output *
read_file_1_svc(read_input *argp, struct svc_req *rqstp) {
    static read_output result;
    int fd = argp->fd;
    int numbytes = argp->numbytes;

    // Initialize output message
    result.success = 0;// Assume failure
    result.buffer.buffer_len = 0;
    result.buffer.buffer_val = NULL;
    result.out_msg.out_msg_len = 0;
    result.out_msg.out_msg_val = NULL;

    // Attempt to read from the file using VirtualDisk
    char *read_buffer = new char[numbytes];
    ssize_t bytes_read = virtualDisk.read(fd, read_buffer, numbytes);
    if (bytes_read < 0) {
        // Read failed, handle the error
        delete[] read_buffer;
        result.out_msg.out_msg_val = strdup("Error reading file");
        return &result;
    } else if (bytes_read == 0) {
        // End of file reached
        result.out_msg.out_msg_val = strdup("End of file reached");
    } else {
        // Read was successful
        result.buffer.buffer_val = read_buffer;
        result.buffer.buffer_len = bytes_read;
        result.success = 1;
    }

    return &result;
}

write_output *
write_file_1_svc(write_input *argp, struct svc_req *rqstp) {
    static write_output result;
    int fd = argp->fd;
    int numbytes = argp->numbytes;
    char *buffer = argp->buffer.buffer_val;

    // Initialize output message
    result.success = 0;// Assume failure
    result.out_msg.out_msg_len = 0;
    result.out_msg.out_msg_val = NULL;

    // Attempt to write to the file using VirtualDisk
    ssize_t bytes_written = virtualDisk.write(fd, buffer, numbytes);
    if (bytes_written < 0) {
        // Write failed, handle the error
        result.out_msg.out_msg_val = strdup("Error writing file");
        return &result;
    }

    // Write was successful
    result.success = 1;

    // Set output message
    char *success_msg = (char *) malloc(50);
    if (success_msg) {
        snprintf(success_msg, 50, "Wrote %zd bytes to file descriptor %d", bytes_written, fd);
        result.out_msg.out_msg_val = success_msg;
        result.out_msg.out_msg_len = strlen(success_msg) + 1;
    } else {
        // Memory allocation for message failed
        result.out_msg.out_msg_val = strdup("Memory allocation for success message failed");
    }

    return &result;
}

list_output *
list_files_1_svc(list_input *argp, struct svc_req *rqstp) {
    static list_output result;

    // Initialize output message
    result.out_msg.out_msg_len = 0;
    result.out_msg.out_msg_val = NULL;

    // Use VirtualDisk to list the files
    std::vector<std::string> files = virtualDisk.list(argp->user_name);
    std::string file_list_str;
    for (const auto& file_name : files) {
        file_list_str += file_name + "\n";
    }

    // Allocate memory for the file list
    char *file_list = strdup(file_list_str.c_str());
    if (file_list == NULL) {
        result.out_msg.out_msg_val = strdup("Memory allocation for file list failed");
        return &result;
    }

    // Set the file list in the result
    result.out_msg.out_msg_val = file_list;
    result.out_msg.out_msg_len = strlen(file_list) + 1;

    return &result;
}

delete_output *
delete_file_1_svc(delete_input *argp, struct svc_req *rqstp) {
    static delete_output result;

    // Initialize output message
    result.out_msg.out_msg_len = 0;
    result.out_msg.out_msg_val = NULL;

    // Use VirtualDisk to delete the file
    int status = virtualDisk.remove(argp->user_name, argp->file_name);
    if (status == -1) {
        // Deletion failed, handle the error
        result.out_msg.out_msg_val = strdup(strerror(errno));
        return &result;
    }

    // Deletion was successful
    char *success_msg = (char *) malloc(50);
    if (success_msg != NULL) {
        snprintf(success_msg, 50, "Deleted file %s", argp->file_name);
        result.out_msg.out_msg_val = success_msg;
        result.out_msg.out_msg_len = strlen(success_msg) + 1;
    } else {
        // Memory allocation for message failed
        result.out_msg.out_msg_val = strdup("Memory allocation for success message failed");
    }

    return &result;
}

close_output *
close_file_1_svc(close_input *argp, struct svc_req *rqstp) {
    static close_output result;
    int fd = argp->fd;

    // Initialize output message
    result.out_msg.out_msg_len = 0;
    result.out_msg.out_msg_val = NULL;

    // Attempt to close the file using VirtualDisk
    if (virtualDisk.close(fd) == -1) {
        // Close failed, handle the error
        result.out_msg.out_msg_val = strdup("Error closing file");
        return &result;
    }

    // Close was successful
    char *success_msg = (char *) malloc(50);
    if (success_msg != NULL) {
        snprintf(success_msg, 50, "Closed file descriptor %d", fd);
        result.out_msg.out_msg_val = success_msg;
        result.out_msg.out_msg_len = strlen(success_msg) + 1;
    } else {
        // Memory allocation for message failed
        result.out_msg.out_msg_val = strdup("Memory allocation for success message failed");
    }

    return &result;
}


seek_output *
seek_position_1_svc(seek_input *argp, struct svc_req *rqstp) {
    static seek_output result;
    int fd = argp->fd;
    off_t position = argp->position;
    off_t new_position;

    // Initialize output message
    result.success = 0;// Assume failure
    result.out_msg.out_msg_len = 0;
    result.out_msg.out_msg_val = NULL;

    // Attempt to seek to the specified position using VirtualDisk
    new_position = virtualDisk.seek(fd, position, SEEK_SET);
    if (new_position == (off_t) -1) {
        // Seek failed, handle the error
        result.out_msg.out_msg_val = strdup("Error seeking file");
        return &result;
    }

    // Seek was successful
    result.success = 1;

    // Set output message
    char *success_msg = (char *) malloc(50);
    if (success_msg != NULL) {
        snprintf(success_msg, 50, "Seeked to position %ld in file descriptor %d", (long) new_position, fd);
        result.out_msg.out_msg_val = success_msg;
        result.out_msg.out_msg_len = strlen(success_msg) + 1;
    } else {
        // Memory allocation for message failed
        result.out_msg.out_msg_val = strdup("Memory allocation for success message failed");
    }

    return &result;
}
